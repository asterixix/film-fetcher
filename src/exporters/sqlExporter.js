const fs = require('fs').promises;
const path = require('path');

class SQLExporter {
  constructor(outputDir = './output') {
    this.outputDir = outputDir;
  }

  async ensureOutputDir() {
    try {
      await fs.access(this.outputDir);
    } catch {
      await fs.mkdir(this.outputDir, { recursive: true });
    }
  }

  escapeString(str) {
    if (str === null || str === undefined) return 'NULL';
    return `'${str.toString().replace(/'/g, "''")}'`;
  }

  formatValue(value) {
    if (value === null || value === undefined) return 'NULL';
    if (typeof value === 'string') return this.escapeString(value);
    if (typeof value === 'boolean') return value ? 1 : 0;
    if (typeof value === 'number') return value;
    if (Array.isArray(value)) return this.escapeString(JSON.stringify(value));
    return this.escapeString(JSON.stringify(value));
  }

  generateCreateTableSQL() {
    return `-- Movie Database Schema
-- Generated by filmweb-fetcher

-- Create movies table
CREATE TABLE IF NOT EXISTS movies (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    title TEXT NOT NULL,
    original_title TEXT,
    release_year INTEGER,
    release_month INTEGER,
    release_day INTEGER,
    country TEXT,
    description TEXT,
    genre TEXT,
    runtime_min INTEGER,
    is_color BOOLEAN,
    gross_worldwide_boxoffice REAL,
    budget REAL,
    distribution TEXT,
    studio TEXT,
    based_on TEXT,
    imdb_id TEXT UNIQUE,
    imdb_rating REAL,
    imdb_vote_count INTEGER,
    tmdb_id INTEGER,
    tmdb_rating REAL,
    tmdb_vote_count INTEGER,
    tmdb_popularity REAL,
    metascore INTEGER,
    metacritic_score INTEGER,
    director TEXT,
    writer TEXT,
    awards TEXT,
    poster_url TEXT,
    backdrop_url TEXT,
    language TEXT,
    rated TEXT,
    dvd_release TEXT,
    website TEXT,
    sources TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Create cast table
CREATE TABLE IF NOT EXISTS cast (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    movie_id INTEGER,
    actor_name TEXT NOT NULL,
    character_role TEXT,
    cast_order INTEGER,
    FOREIGN KEY (movie_id) REFERENCES movies (id)
);

-- Create alternative_titles table
CREATE TABLE IF NOT EXISTS alternative_titles (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    movie_id INTEGER,
    title TEXT NOT NULL,
    country TEXT,
    FOREIGN KEY (movie_id) REFERENCES movies (id)
);

-- Create genres table (normalized)
CREATE TABLE IF NOT EXISTS genres (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    name TEXT UNIQUE NOT NULL
);

-- Create movie_genres junction table
CREATE TABLE IF NOT EXISTS movie_genres (
    movie_id INTEGER,
    genre_id INTEGER,
    PRIMARY KEY (movie_id, genre_id),
    FOREIGN KEY (movie_id) REFERENCES movies (id),
    FOREIGN KEY (genre_id) REFERENCES genres (id)
);

-- Create countries table (normalized)
CREATE TABLE IF NOT EXISTS countries (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    code TEXT UNIQUE,
    name TEXT UNIQUE NOT NULL
);

-- Create movie_countries junction table
CREATE TABLE IF NOT EXISTS movie_countries (
    movie_id INTEGER,
    country_id INTEGER,
    PRIMARY KEY (movie_id, country_id),
    FOREIGN KEY (movie_id) REFERENCES movies (id),
    FOREIGN KEY (country_id) REFERENCES countries (id)
);

-- Create indexes for better performance
CREATE INDEX IF NOT EXISTS idx_movies_imdb_id ON movies(imdb_id);
CREATE INDEX IF NOT EXISTS idx_movies_tmdb_id ON movies(tmdb_id);
CREATE INDEX IF NOT EXISTS idx_movies_title ON movies(title);
CREATE INDEX IF NOT EXISTS idx_movies_release_year ON movies(release_year);
CREATE INDEX IF NOT EXISTS idx_movies_rating ON movies(imdb_rating);
CREATE INDEX IF NOT EXISTS idx_cast_movie_id ON cast(movie_id);
CREATE INDEX IF NOT EXISTS idx_cast_actor_name ON cast(actor_name);

`;
  }

  generateInsertSQL(movies) {
    let sql = this.generateCreateTableSQL();
    sql += '\n-- Insert movie data\nBEGIN TRANSACTION;\n\n';

    // Insert movies
    for (let i = 0; i < movies.length; i++) {
      const movie = movies[i];
      const movieId = i + 1; // Simple auto-increment simulation

      // Insert movie record
      sql += `INSERT OR REPLACE INTO movies (
        id, title, original_title, release_year, release_month, release_day,
        country, description, genre, runtime_min, is_color,
        gross_worldwide_boxoffice, budget, distribution, studio, based_on,
        imdb_id, imdb_rating, imdb_vote_count, tmdb_id, tmdb_rating,
        tmdb_vote_count, tmdb_popularity, metascore, metacritic_score,
        director, writer, awards, poster_url, backdrop_url,
        language, rated, dvd_release, website, sources
      ) VALUES (
        ${movieId},
        ${this.formatValue(movie.title)},
        ${this.formatValue(movie.original_title)},
        ${this.formatValue(movie.release_year)},
        ${this.formatValue(movie.release_month)},
        ${this.formatValue(movie.release_day)},
        ${this.formatValue(movie.country)},
        ${this.formatValue(movie.description)},
        ${this.formatValue(movie.genre)},
        ${this.formatValue(movie.runtime_min)},
        ${this.formatValue(movie.is_color)},
        ${this.formatValue(movie.gross_worldwide_boxoffice)},
        ${this.formatValue(movie.budget)},
        ${this.formatValue(movie.distribution)},
        ${this.formatValue(movie.studio)},
        ${this.formatValue(movie.based_on)},
        ${this.formatValue(movie.imdb_id)},
        ${this.formatValue(movie.imdb_rating)},
        ${this.formatValue(movie.imdb_vote_count)},
        ${this.formatValue(movie.tmdb_id)},
        ${this.formatValue(movie.tmdb_rating)},
        ${this.formatValue(movie.tmdb_vote_count)},
        ${this.formatValue(movie.popularity)},
        ${this.formatValue(movie.metascore)},
        ${this.formatValue(movie.metacritic_score)},
        ${this.formatValue(movie.director)},
        ${this.formatValue(movie.writer)},
        ${this.formatValue(movie.awards)},
        ${this.formatValue(movie.poster_url)},
        ${this.formatValue(movie.backdrop_url)},
        ${this.formatValue(movie.language)},
        ${this.formatValue(movie.rated)},
        ${this.formatValue(movie.dvd_release)},
        ${this.formatValue(movie.website)},
        ${this.formatValue(Array.isArray(movie.sources) ? movie.sources.join(', ') : movie.source)}
      );\n\n`;

      // Insert cast
      if (Array.isArray(movie.cast)) {
        movie.cast.forEach((actor, castIndex) => {
          sql += `INSERT INTO cast (movie_id, actor_name, character_role, cast_order) VALUES (
            ${movieId},
            ${this.formatValue(actor.name)},
            ${this.formatValue(actor.role)},
            ${castIndex + 1}
          );\n`;
        });
      }

      // Insert alternative titles
      if (Array.isArray(movie.other_titles)) {
        movie.other_titles.forEach((altTitle) => {
          sql += `INSERT INTO alternative_titles (movie_id, title, country) VALUES (
            ${movieId},
            ${this.formatValue(altTitle.title)},
            ${this.formatValue(altTitle.country)}
          );\n`;
        });
      }

      sql += '\n';
    }

    sql += 'COMMIT;\n\n';

    // Add some useful queries at the end
    sql += `-- Sample queries
-- Get movies by rating
-- SELECT * FROM movies WHERE imdb_rating >= 8.0 ORDER BY imdb_rating DESC;

-- Get movies with cast
-- SELECT m.title, c.actor_name, c.character_role 
-- FROM movies m 
-- JOIN cast c ON m.id = c.movie_id 
-- WHERE m.title = 'The Matrix';

-- Get movies by year range
-- SELECT title, release_year, imdb_rating 
-- FROM movies 
-- WHERE release_year BETWEEN 1990 AND 2000 
-- ORDER BY imdb_rating DESC;

-- Get top rated movies
-- SELECT title, imdb_rating, imdb_vote_count 
-- FROM movies 
-- WHERE imdb_rating IS NOT NULL 
-- ORDER BY imdb_rating DESC, imdb_vote_count DESC 
-- LIMIT 10;
`;

    return sql;
  }

  async exportMovies(movies, filename = 'movies.sql') {
    await this.ensureOutputDir();
    
    const filePath = path.join(this.outputDir, filename);
    const sqlContent = this.generateInsertSQL(movies);
    
    await fs.writeFile(filePath, sqlContent, 'utf8');
    
    return filePath;
  }

  async exportSchema(filename = 'schema.sql') {
    await this.ensureOutputDir();
    
    const filePath = path.join(this.outputDir, filename);
    const schemaContent = this.generateCreateTableSQL();
    
    await fs.writeFile(filePath, schemaContent, 'utf8');
    
    return filePath;
  }
}

module.exports = SQLExporter;
